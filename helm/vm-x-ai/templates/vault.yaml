{{- if .Values.vault.enabled }}
{{- $vaultStorageHost := .Values.vault.postgresStorage.host }}
{{- if not $vaultStorageHost }}
{{- $vaultStorageHost = printf "%s-postgresql" (include "vm-x-ai.fullname" .) }}
{{- end }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "vm-x-ai.fullname" . }}-vault-config
  labels:
    {{- include "vm-x-ai.labels" . | nindent 4 }}
    app.kubernetes.io/component: vault
data:
  vault.hcl: |
    ui = true
    {{- if eq .Values.vault.storage "file" }}
    storage "file" {
      path = "/vault/file"
    }
    {{- else }}
    storage "postgresql" {
      connection_url = "postgresql://{{ .Values.vault.postgresStorage.username }}:$(cat /vault/secrets/postgres-password)@{{ $vaultStorageHost }}:{{ .Values.vault.postgresStorage.port }}/{{ .Values.vault.postgresStorage.database }}?sslmode=disable"
    }
    {{- end }}
    {{- if .Values.vault.selfSealed }}
    listener "tcp" {
      address = "0.0.0.0:8200"
      tls_disable = 1
    }
    seal "transit" {
      address = "http://{{ include "vm-x-ai.fullname" . }}-vault-kms:8200"
      disable_renewal = "false"
      key_name = "autounseal"
      mount_path = "transit/"
      tls_skip_verify = "true"
    }
    {{- else }}
    listener "tcp" {
      address = "0.0.0.0:8200"
      tls_disable = 1
    }
    # Vault will need to be unsealed manually or via external KMS
    {{- end }}
  init.sh: |
    #!/bin/sh
    set -e
    
    {{- if .Values.vault.selfSealed }}
    # Wait for vault-kms to be ready
    echo "Waiting for Vault KMS to be ready..."
    until vault status -address=http://{{ include "vm-x-ai.fullname" . }}-vault-kms:8200 > /dev/null 2>&1; do
      echo "Vault KMS is not ready yet. Waiting..."
      sleep 2
    done
    
    # Initialize vault if not already initialized
    if ! vault status -address=http://127.0.0.1:8200 2>/dev/null | grep -q "Initialized.*true"; then
      echo "Initializing Vault..."
      vault operator init -address=http://127.0.0.1:8200 -key-shares=1 -key-threshold=1 -format=json > /tmp/vault-init.json
      
      UNSEAL_KEY=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[0]')
      ROOT_TOKEN=$(cat /tmp/vault-init.json | jq -r '.root_token')
      
      echo "$ROOT_TOKEN" > /vault/config/root-token.txt
      
      echo "Unsealing Vault..."
      vault operator unseal -address=http://127.0.0.1:8200 "$UNSEAL_KEY"
    else
      echo "Vault is already initialized"
      # Try to unseal if sealed
      if vault status -address=http://127.0.0.1:8200 2>/dev/null | grep -q "Sealed.*true"; then
        if [ -f /vault/config/root-token.txt ]; then
          ROOT_TOKEN=$(cat /vault/config/root-token.txt)
          # For self-sealed mode, we need the unseal key
          # This is a simplified version - in production, use proper key management
          echo "Vault is sealed. Please unseal manually or configure auto-unseal."
        fi
      fi
    fi
    
    # Start vault server
    exec vault server -config=/vault/config/vault.hcl
    {{- else }}
    # Non-self-sealed mode - vault needs to be initialized and unsealed manually
    echo "Starting Vault in non-self-sealed mode..."
    echo "Vault must be initialized and unsealed manually or via external KMS"
    exec vault server -config=/vault/config/vault.hcl
    {{- end }}
---
{{- if .Values.vault.selfSealed }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "vm-x-ai.fullname" . }}-vault-kms
  labels:
    {{- include "vm-x-ai.labels" . | nindent 4 }}
    app.kubernetes.io/component: vault-kms
spec:
  replicas: 1
  selector:
    matchLabels:
      {{- include "vm-x-ai.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: vault-kms
  template:
    metadata:
      labels:
        {{- include "vm-x-ai.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: vault-kms
    spec:
      {{- with .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      containers:
      - name: vault-kms
        image: {{ printf "%s:%s" .Values.vault.vaultKms.image.repository .Values.vault.vaultKms.image.tag }}
        imagePullPolicy: {{ .Values.vault.vaultKms.image.pullPolicy }}
        ports:
        - name: http
          containerPort: 8200
          protocol: TCP
        command:
        - /bin/sh
        - -c
        - |
          vault server -dev -dev-root-token-id=root -dev-listen-address=0.0.0.0:8200 &
          sleep 5
          export VAULT_ADDR=http://127.0.0.1:8200
          export VAULT_TOKEN=root
          vault secrets enable transit
          vault write -f transit/keys/autounseal type=aes256-gcm96
          wait
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
---
apiVersion: v1
kind: Service
metadata:
  name: {{ include "vm-x-ai.fullname" . }}-vault-kms
  labels:
    {{- include "vm-x-ai.labels" . | nindent 4 }}
    app.kubernetes.io/component: vault-kms
spec:
  type: ClusterIP
  ports:
    - port: 8200
      targetPort: http
      protocol: TCP
      name: http
  selector:
    {{- include "vm-x-ai.selectorLabels" . | nindent 4 }}
    app.kubernetes.io/component: vault-kms
---
{{- end }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "vm-x-ai.fullname" . }}-vault
  labels:
    {{- include "vm-x-ai.labels" . | nindent 4 }}
    app.kubernetes.io/component: vault
spec:
  replicas: 1
  selector:
    matchLabels:
      {{- include "vm-x-ai.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: vault
  template:
    metadata:
      labels:
        {{- include "vm-x-ai.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: vault
    spec:
      {{- with .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      securityContext:
        runAsNonRoot: false
        runAsUser: 0
      containers:
      - name: vault
        image: {{ printf "%s:%s" .Values.vault.image.repository .Values.vault.image.tag }}
        imagePullPolicy: {{ .Values.vault.image.pullPolicy }}
        ports:
        - name: http
          containerPort: 8200
          protocol: TCP
        command:
        - /bin/sh
        - /vault/config/init.sh
        env:
        {{- if eq .Values.vault.storage "postgresql" }}
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ include "vm-x-ai.fullname" . }}-database
              key: password
        {{- end }}
        volumeMounts:
        - name: config
          mountPath: /vault/config
        {{- if eq .Values.vault.storage "file" }}
        - name: file
          mountPath: /vault/file
        {{- end }}
        resources:
          {{- toYaml .Values.vault.resources | nindent 10 }}
        securityContext:
          capabilities:
            add:
            - IPC_LOCK
        livenessProbe:
          httpGet:
            path: /v1/sys/health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /v1/sys/health
            port: http
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: config
        configMap:
          name: {{ include "vm-x-ai.fullname" . }}-vault-config
      {{- if eq .Values.vault.storage "file" }}
      - name: file
        {{- if .Values.vault.fileStorage.persistence.enabled }}
        persistentVolumeClaim:
          claimName: {{ include "vm-x-ai.fullname" . }}-vault-file
        {{- else }}
        emptyDir: {}
        {{- end }}
      {{- end }}
---
{{- if and (eq .Values.vault.storage "file") .Values.vault.fileStorage.persistence.enabled }}
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ include "vm-x-ai.fullname" . }}-vault-file
  labels:
    {{- include "vm-x-ai.labels" . | nindent 4 }}
    app.kubernetes.io/component: vault
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: {{ .Values.vault.fileStorage.persistence.size }}
  {{- if .Values.vault.fileStorage.persistence.storageClass }}
  storageClassName: {{ .Values.vault.fileStorage.persistence.storageClass }}
  {{- end }}
---
{{- end }}
apiVersion: v1
kind: Service
metadata:
  name: {{ include "vm-x-ai.fullname" . }}-vault
  labels:
    {{- include "vm-x-ai.labels" . | nindent 4 }}
    app.kubernetes.io/component: vault
spec:
  type: {{ .Values.vault.service.type }}
  ports:
    - port: {{ .Values.vault.service.port }}
      targetPort: http
      protocol: TCP
      name: http
  selector:
    {{- include "vm-x-ai.selectorLabels" . | nindent 4 }}
    app.kubernetes.io/component: vault
---
{{- if and .Values.vault.enabled (eq .Values.api.vault.encryptionService "hashcorp") }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "vm-x-ai.fullname" . }}-vault-bootstrap
  labels:
    {{- include "vm-x-ai.labels" . | nindent 4 }}
    app.kubernetes.io/component: vault
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "0"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    metadata:
      labels:
        {{- include "vm-x-ai.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: vault
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ include "vm-x-ai.serviceAccountName" . }}
      {{- with .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      containers:
      - name: vault-bootstrap
        image: {{ printf "%s:%s" .Values.vault.image.repository .Values.vault.image.tag }}
        imagePullPolicy: {{ .Values.vault.image.pullPolicy }}
        command:
        - /bin/sh
        - -c
        - |
          set -e
          VAULT_ADDR=http://{{ include "vm-x-ai.fullname" . }}-vault:{{ .Values.vault.service.port }}
          
          # Wait for vault to be ready (initialized and unsealed)
          echo "Waiting for Vault to be ready..."
          MAX_WAIT=180
          WAIT_COUNT=0
          while true; do
            # Try to get vault status
            VAULT_STATUS_OUTPUT=$(vault status -address="$VAULT_ADDR" 2>&1)
            VAULT_STATUS_EXIT=$?
            
            # Check if vault is responding and unsealed
            if [ $VAULT_STATUS_EXIT -eq 0 ]; then
              # Vault is responding - check if it's unsealed
              if echo "$VAULT_STATUS_OUTPUT" | grep -q "Sealed.*false"; then
                echo "Vault is unsealed and ready!"
                echo "Vault status:"
                echo "$VAULT_STATUS_OUTPUT"
                break
              elif echo "$VAULT_STATUS_OUTPUT" | grep -q "Sealed.*true"; then
                # Vault is sealed - wait for auto-unseal (in self-sealed mode)
                if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
                  echo "Error: Vault is still sealed after $MAX_WAIT seconds"
                  echo "Vault status:"
                  echo "$VAULT_STATUS_OUTPUT"
                  echo ""
                  echo "In self-sealed mode, vault should auto-unseal via transit key."
                  echo "Check vault pod logs for initialization issues:"
                  echo "  kubectl logs -l app.kubernetes.io/component=vault"
                  exit 1
                fi
                echo "Vault is sealed, waiting for auto-unseal... ($WAIT_COUNT/$MAX_WAIT)"
              else
                # Unexpected status
                echo "Vault status: $VAULT_STATUS_OUTPUT"
                if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
                  echo "Error: Unexpected vault status after $MAX_WAIT seconds"
                  exit 1
                fi
                echo "Waiting for vault... ($WAIT_COUNT/$MAX_WAIT)"
              fi
            else
              # Vault is not responding yet (might not be initialized or not started)
              if echo "$VAULT_STATUS_OUTPUT" | grep -q "connection refused\|dial tcp"; then
                # Service not available yet
                if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
                  echo "Error: Vault service is not responding after $MAX_WAIT seconds"
                  echo "This might mean vault pod is not running. Check:"
                  echo "  kubectl get pods -l app.kubernetes.io/component=vault"
                  echo "  kubectl logs -l app.kubernetes.io/component=vault"
                  exit 1
                fi
                echo "Vault service is not responding yet. Waiting... ($WAIT_COUNT/$MAX_WAIT)"
              elif echo "$VAULT_STATUS_OUTPUT" | grep -q "not initialized"; then
                # Vault is not initialized yet - this is okay, keep waiting
                if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
                  echo "Error: Vault is not initialized after $MAX_WAIT seconds"
                  echo "Check vault pod logs for initialization issues:"
                  echo "  kubectl logs -l app.kubernetes.io/component=vault"
                  exit 1
                fi
                echo "Vault is not initialized yet. Waiting... ($WAIT_COUNT/$MAX_WAIT)"
              else
                # Some other error
                if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
                  echo "Error: Vault error after $MAX_WAIT seconds"
                  echo "Status: $VAULT_STATUS_OUTPUT"
                  exit 1
                fi
                echo "Waiting for vault... ($WAIT_COUNT/$MAX_WAIT)"
                echo "Status: $VAULT_STATUS_OUTPUT"
              fi
            fi
            
            sleep 2
            WAIT_COUNT=$((WAIT_COUNT + 2))
          done
          
          # Get root token
          {{- if .Values.vault.selfSealed }}
          ROOT_TOKEN=$(cat /vault/config/root-token.txt)
          {{- else }}
          # In non-self-sealed mode, root token should be provided via secret
          ROOT_TOKEN=$(cat /vault/secrets/root-token)
          {{- end }}
          
          export VAULT_TOKEN="$ROOT_TOKEN"
          
          # Enable approle auth
          if ! vault auth list | grep -q "^approle/"; then
            echo "Enabling approle authentication..."
            vault auth enable approle
          fi
          
          # Create policy
          echo "Writing VMXAI policy..."
          vault policy write vmxai-policy - <<EOF
          path "transit/encrypt/vmxai-key" {
            capabilities = ["update"]
          }
          path "transit/decrypt/vmxai-key" {
            capabilities = ["update"]
          }
          path "secret/data/*" {
            capabilities = ["create", "read", "update", "delete"]
          }
          EOF
          
          # Create approle role
          if ! vault read auth/approle/role/{{ .Values.vault.bootstrap.approleRoleName }} > /dev/null 2>&1; then
            echo "Creating approle role..."
            vault write auth/approle/role/{{ .Values.vault.bootstrap.approleRoleName }} \
              token_policies="vmxai-policy" \
              token_ttl=1h \
              token_max_ttl=4h
          fi
          
          # Enable transit secrets engine
          if ! vault secrets list | grep -q "^transit/"; then
            echo "Enabling transit secrets engine..."
            vault secrets enable transit
          fi
          
          # Create transit key
          if ! vault read transit/keys/vmxai-key > /dev/null 2>&1; then
            echo "Creating transit key..."
            vault write -f transit/keys/vmxai-key type=aes256-gcm96
          fi
          
          # Enable KV v2 secrets engine
          if ! vault secrets list | grep -q "^secret/"; then
            echo "Enabling KV v2 secrets engine..."
            vault secrets enable -version=2 -path=secret kv
          fi
          
          # Get role-id and secret-id
          ROLE_ID=$(vault read auth/approle/role/{{ .Values.vault.bootstrap.approleRoleName }}/role-id -format=json | jq -r '.data.role_id')
          SECRET_ID=$(vault write -f auth/approle/role/{{ .Values.vault.bootstrap.approleRoleName }}/secret-id -format=json | jq -r '.data.secret_id')
          
          # Write credentials to shared volume for API to read
          echo -n "$ROLE_ID" > /shared/role-id
          echo -n "$SECRET_ID" > /shared/secret-id
          
          # Try to update secret using Kubernetes API
          # First check if secret exists and has empty values
          if command -v kubectl > /dev/null 2>&1; then
            echo "Updating Kubernetes secret..."
            # Create or update the secret
            kubectl create secret generic {{ include "vm-x-ai.fullname" . }}-vault-approle \
              --from-literal=role-id="$ROLE_ID" \
              --from-literal=secret-id="$SECRET_ID" \
              --dry-run=client -o yaml | \
              kubectl apply -f - || \
              kubectl patch secret {{ include "vm-x-ai.fullname" . }}-vault-approle \
                --type=json \
                -p="[{\"op\":\"replace\",\"path\":\"/data/role-id\",\"value\":\"$(echo -n $ROLE_ID | base64)\"},{\"op\":\"replace\",\"path\":\"/data/secret-id\",\"value\":\"$(echo -n $SECRET_ID | base64)\"}]"
          else
            echo "kubectl not available. Credentials written to /shared/"
            echo "Please manually update the secret {{ include "vm-x-ai.fullname" . }}-vault-approle with:"
            echo "  role-id: $(echo -n $ROLE_ID | base64)"
            echo "  secret-id: $(echo -n $SECRET_ID | base64)"
          fi
          
          echo "Vault bootstrap completed successfully"
        env:
        {{- if .Values.vault.selfSealed }}
        - name: VAULT_TOKEN
          valueFrom:
            secretKeyRef:
              name: {{ include "vm-x-ai.fullname" . }}-vault
              key: root-token
        {{- end }}
        volumeMounts:
        - name: vault-config
          mountPath: /vault/config
        - name: vault-secrets
          mountPath: /vault/secrets
        - name: shared
          mountPath: /shared
      volumes:
      - name: vault-config
        configMap:
          name: {{ include "vm-x-ai.fullname" . }}-vault-config
      - name: vault-secrets
        secret:
          secretName: {{ include "vm-x-ai.fullname" . }}-vault
      - name: shared
        emptyDir: {}
{{- end }}
{{- end }}

