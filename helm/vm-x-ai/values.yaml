# Default values for vm-x-ai
# This is a YAML-formatted file.

# Global settings
global:
  imageRegistry: ""
  imagePullSecrets: []

# Application images
images:
  api:
    repository: vmxai/api
    tag: "2512.11.94f0dae"
    pullPolicy: IfNotPresent
  ui:
    repository: vmxai/ui
    tag: "2512.11.94f0dae"
    pullPolicy: IfNotPresent

# API Configuration
api:
  enabled: true
  replicaCount: 2
  
  service:
    type: ClusterIP
    port: 3000
    targetPort: 3000
  
  resources:
    requests:
      cpu: 500m
      memory: 512Mi
    limits:
      cpu: 2000m
      memory: 2Gi
  
  env:
    LOG_LEVEL: info
    NODE_ENV: production
    PORT: 3000
    BASE_URL: "" # Will be set based on ingress or service
    UI_BASE_URL: "" # Will be set based on ingress or service
    OIDC_PROVIDER_ISSUER: "" # Will be set based on BASE_URL
    DATABASE_WRITER_POOL_MAX: 25
    DATABASE_READER_POOL_MAX: 50
    BATCH_QUEUE_VISIBILITY_TIMEOUT: 120000
  
  # Encryption Provider Configuration
  # Options: libsodium (default, for local/small deployments) or aws-kms (for production)
  encryption:
    provider: libsodium # libsodium or aws-kms
    libsodium:
      # Encryption key for libsodium (base64 encoded, 32 bytes)
      # Will be auto-generated if not provided via secrets
      encryptionKey: "" # Will be set from secrets
    awsKms:
      keyId: "" # Required if using aws-kms (e.g., "arn:aws:kms:region:account:key/key-id")
  
  # Timeseries DB Configuration
  timeseriesDb:
    provider: questdb # questdb or aws-timestream
    questdb:
      host: "" # Will be set automatically if questdb is enabled
      port: 8812
      user: admin
      password: "" # Will be set from secrets
      dbName: vmxai
    awsTimestream:
      databaseName: "" # Required if using aws-timestream
  
  # OIDC Federated Login (optional)
  oidcFederated:
    enabled: false
    issuer: ""
    clientId: ""
    # clientSecret is optional - only set if your OIDC provider requires it
    # If set, a secret will be created/referenced for the client secret
    clientSecret: "" # Optional - set to enable client secret authentication
    scope: "openid profile email"
    defaultRole: "power-user"
  
  nodeSelector: {}
  tolerations: []
  affinity: {}
  
  # Pod disruption budget
  podDisruptionBudget:
    enabled: true
    minAvailable: 1

# UI Configuration
ui:
  enabled: true
  replicaCount: 2
  
  service:
    type: ClusterIP
    port: 3001
    targetPort: 3001
  
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi
  
  env:
    AUTH_URL: "" # Will be set based on ingress or service
    AUTH_SECRET: "" # Will be set from secrets
    AUTH_OIDC_ISSUER: "" # Will be set based on API BASE_URL
    AUTH_OIDC_CLIENT_ID: ui
    AUTH_OIDC_CLIENT_SECRET: ui
    AUTH_REDIRECT_PROXY_URL: "" # Will be set based on ingress or service
    API_BASE_URL: "" # Will be set based on API service
  
  nodeSelector: {}
  tolerations: []
  affinity: {}

# PostgreSQL Configuration
postgresql:
  # Set to false to use external PostgreSQL
  enabled: true
  
  # If enabled, these values are used
  image:
    repository: postgres
    tag: "15"
    pullPolicy: IfNotPresent
  
  auth:
    postgresPassword: "" # Will be generated if not set
    database: vmxai
    username: admin
  
  persistence:
    enabled: true
    size: 20Gi
    storageClass: ""
  
  resources:
    requests:
      cpu: 500m
      memory: 512Mi
    limits:
      cpu: 2000m
      memory: 2Gi
  
  service:
    type: ClusterIP
    port: 5432
  
  # If disabled, provide external connection details
  external:
    host: ""
    port: 5432
    database: ""
    username: ""
    password: "" # Will be set from secrets
    # For read replicas
    roHost: "" # If not set, uses host

# Redis Configuration
redis:
  # Set to false to use external Redis
  enabled: true
  
  # Mode: single or cluster
  mode: single # single or cluster
  
  # Single node configuration
  single:
    image:
      repository: redis
      tag: "7"
      pullPolicy: IfNotPresent
    
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ""
    
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    
    service:
      type: ClusterIP
      port: 6379
  
  # Cluster configuration
  cluster:
    nodes: 3
    replicas: 0 # Number of replicas per master
    
    image:
      repository: redis
      tag: "7"
      pullPolicy: IfNotPresent
    
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ""
    
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    
    service:
      type: ClusterIP
      ports:
        - name: client
          port: 6379
        - name: cluster
          port: 16379
  
  # If disabled, provide external connection details
  external:
    host: ""
    port: 6379
    # For cluster mode, provide all nodes
    nodes: [] # Array of {host: "", port: 6379}

# QuestDB Configuration
questdb:
  # Set to false if using aws-timestream
  enabled: true
  
  image:
    repository: questdb/questdb
    tag: "9.1.1"
    pullPolicy: IfNotPresent
  
  auth:
    user: admin
    password: "" # Will be generated if not set
    database: vmxai
  
  persistence:
    enabled: true
    size: 50Gi
    storageClass: ""
  
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 4Gi
  
  service:
    type: ClusterIP
    ports:
      - name: http
        port: 9000
      - name: postgres
        port: 8812


# OpenTelemetry Services
otel:
  enabled: false
  
  collector:
    enabled: false
    image:
      repository: otel/opentelemetry-collector-contrib
      tag: latest
      pullPolicy: IfNotPresent
    
    service:
      type: ClusterIP
      ports:
        - name: otlp-grpc
          port: 4317
        - name: otlp-http
          port: 4318
        - name: zpages
          port: 55679
    
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
  
  jaeger:
    enabled: false
    image:
      repository: jaegertracing/all-in-one
      tag: latest
      pullPolicy: IfNotPresent
    
    service:
      type: ClusterIP
      ports:
        - name: ui
          port: 16686
        - name: collector-http
          port: 14268
        - name: collector-grpc
          port: 14250
    
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
  
  prometheus:
    enabled: false
    image:
      repository: prom/prometheus
      tag: latest
      pullPolicy: IfNotPresent
    
    service:
      type: ClusterIP
      port: 9090
    
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ""
    
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 1000m
        memory: 2Gi
  
  loki:
    enabled: false
    image:
      repository: grafana/loki
      tag: latest
      pullPolicy: IfNotPresent
    
    service:
      type: ClusterIP
      port: 3100
    
    persistence:
      enabled: true
      size: 20Gi
      storageClass: ""
    
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 1000m
        memory: 2Gi
  
  grafana:
    enabled: false
    image:
      repository: grafana/grafana
      tag: latest
      pullPolicy: IfNotPresent
    
    service:
      type: ClusterIP
      port: 3000
    
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ""
    
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi

# Secrets Configuration
# WARNING: Do NOT store secrets in values.yaml for production!
# Use one of the following production-safe methods:
# 1. External Secrets Operator (recommended)
# 2. Sealed Secrets
# 3. Reference existing Kubernetes secrets
# 4. Use secret management systems (Vault, AWS Secrets Manager, etc.)
secrets:
  # Method: "create" (auto-generate), "external" (use existing), "eso" (External Secrets Operator)
  # For production, use "external" or "eso"
  method: create  # create, external, eso
  
  # Option 1: Auto-generate (DEVELOPMENT ONLY - NOT FOR PRODUCTION)
  # When method: "create", secrets are always auto-generated
  
  # Option 2: Reference existing Kubernetes secrets (PRODUCTION-SAFE)
  # When method: "external", reference existing secrets by name
  external:
    database:
      secretName: ""  # e.g., "postgresql-credentials"
      passwordKey: "password"  # Key name in the secret
      hostKey: "host"  # Optional, only if using external PostgreSQL
      portKey: "port"  # Optional, only if using external PostgreSQL
      databaseKey: "database"  # Optional, only if using external PostgreSQL
      usernameKey: "username"  # Optional, only if using external PostgreSQL
    questdb:
      secretName: ""  # e.g., "questdb-credentials"
      passwordKey: "password"
    libsodium:
      # Only needed if api.encryption.provider is libsodium
      secretName: ""  # e.g., "libsodium-encryption-key"
      encryptionKeyKey: "encryption-key"
    ui:
      secretName: ""  # e.g., "ui-auth-secret"
      authSecretKey: "auth-secret"
    oidcFederated:
      secretName: ""  # e.g., "oidc-federated-secret"
      clientSecretKey: "client-secret"
  
  # Option 3: External Secrets Operator (PRODUCTION-SAFE)
  # When method: "eso", creates ExternalSecret resources
  # Requires External Secrets Operator to be installed
  externalSecrets:
    enabled: false
    # Secret Store to use (must exist in cluster)
    secretStore:
      name: ""  # e.g., "aws-secrets-manager"
      kind: SecretStore  # or ClusterSecretStore
    # Secret references from your secret store
    database:
      secretKey: ""  # e.g., "vmxai/postgresql/password"
      passwordKey: "password"
      hostKey: "host"
      portKey: "port"
      databaseKey: "database"
      usernameKey: "username"
    questdb:
      secretKey: ""  # e.g., "vmxai/questdb/password"
      passwordKey: "password"
    libsodium:
      secretKey: ""  # e.g., "vmxai/encryption/libsodium-key"
      encryptionKeyKey: "encryption-key"
    ui:
      secretKey: ""  # e.g., "vmxai/ui/auth-secret"
      authSecretKey: "auth-secret"
    oidcFederated:
      # Only needed if api.oidcFederated.clientSecret is set
      secretKey: ""  # e.g., "vmxai/oidc/client-secret"
      clientSecretKey: "client-secret"

# Ingress Configuration
# Choose between "nginx" (standard Kubernetes Ingress) or "istio" (Istio Gateway + VirtualService)
ingress:
  type: nginx  # nginx or istio
  enabled: false
  
  # Nginx Ingress Configuration
  nginx:
    className: ""
    annotations: {}
    hosts:
      - host: vm-x-ai.example.com
        paths:
          - path: /
            pathType: Prefix
            service: ui
          - path: /api
            pathType: Prefix
            service: api
    tls: []
    #  - secretName: vm-x-ai-tls
    #    hosts:
    #      - vm-x-ai.example.com
  
  # Istio Gateway and VirtualService Configuration
  istio:
    # Gateway configuration
    gateway:
      name: vm-x-ai-gateway
      namespace: istio-system  # Usually deployed in istio-system
      selector:
        istio: ingressgateway
      servers:
        - port:
            number: 80
            name: http
            protocol: HTTP
          hosts:
            - vm-x-ai.example.com
        - port:
            number: 443
            name: https
            protocol: HTTPS
          tls:
            mode: SIMPLE
            credentialName: vm-x-ai-tls  # Secret in istio-system namespace
          hosts:
            - vm-x-ai.example.com
    
    # VirtualService configuration
    virtualService:
      hosts:
        - vm-x-ai.example.com
      gateways:
        - istio-system/vm-x-ai-gateway
      
      # Optional: Traffic management features
      # These apply to all routes unless overridden per-route
      trafficPolicy:
        # Load balancer settings
        # Options: ROUND_ROBIN, LEAST_CONN, RANDOM, PASSTHROUGH
        loadBalancer:
          simple: LEAST_CONN
        # Connection pool settings
        connectionPool:
          tcp:
            maxConnections: 100
          http:
            http1MaxPendingRequests: 10
            http2MaxRequests: 100
            maxRequestsPerConnection: 2
        # Circuit breaker
        outlierDetection:
          consecutiveErrors: 3
          interval: 30s
          baseEjectionTime: 30s
          maxEjectionPercent: 50
          minHealthPercent: 50

# Service Account
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Pod Security Context
podSecurityContext:
  fsGroup: 2000

# Security Context
securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1000

# Additional labels and annotations
commonLabels: {}
commonAnnotations: {}

